package internal

import (
	"fmt"
	"os"
)

const fileHeaderText = "// Code generated by \"enumer\"; DO NOT EDIT. \n\n"

var (
	supportedTypes = map[string]string{
		"string": "string",
		"int":    "int",
		"int32":  "int",
		"int64":  "int",
	}
)

func GenerateEnumFile(fileName, packageName string, enums []*FutureEnum) error {
	if len(enums) == 0 {
		return nil
	}
	file, err := os.Create(fileName)
	if err != nil {
		return err
	}
	defer file.Close()
	file.WriteString(fileHeaderText)
	file.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	for _, enumInfo := range enums {
		// Generate const values
		file.WriteString(fmt.Sprintf("// %s enum declarations\nconst (\n", enumInfo.EnumName))
		switch enumInfo.TypeName { // Generate enum values long name const
		case "int":
			file.WriteString(fmt.Sprintf("\t_%sName = \"", enumInfo.EnumName))
			for _, value := range enumInfo.ValueNames {
				file.WriteString(value)
			}
			file.WriteString("\"\n")
		}

		for i, value := range enumInfo.ValueNames { // Generate enum values
			fieldName := genEnumName(value, enumInfo.EnumName, enumInfo.reversedName)
			switch enumInfo.TypeName {
			case "int":
				if i == 0 {
					file.WriteString(fmt.Sprintf("\t%s %s = iota\n", fieldName, enumInfo.EnumName))
				} else {
					file.WriteString(fmt.Sprintf("\t%s\n", fieldName))
				}
			case "string":
				file.WriteString(fmt.Sprintf("\t%s %s = \"%s\"\n", fieldName, enumInfo.EnumName, value))
			}
		}
		file.WriteString(")\n\n")

		// Generate name list
		switch enumInfo.TypeName {
		case "int":
			file.WriteString(fmt.Sprintf("var _%sNames = []string{\n", enumInfo.EnumName))
			prevIndex := 0
			for _, value := range enumInfo.ValueNames {
				newIndex := prevIndex + len(value)
				file.WriteString(fmt.Sprintf("\t_%sName[%d:%d],\n", enumInfo.EnumName, prevIndex, newIndex))
				prevIndex = newIndex
			}
			file.WriteString("}\n\n")

			file.WriteString(fmt.Sprintf("var _%sMap = map[string]%s{\n", enumInfo.EnumName, enumInfo.EnumName))
			prevIndex = 0
			for _, value := range enumInfo.ValueNames {
				fieldName := genEnumName(value, enumInfo.EnumName, enumInfo.reversedName)
				newIndex := prevIndex + len(value)
				file.WriteString(fmt.Sprintf("\t_%sName[%d:%d]: %s,\n", enumInfo.EnumName, prevIndex, newIndex, fieldName))
				prevIndex = newIndex
			}
			file.WriteString("}\n\n")

			file.WriteString(fmt.Sprintf("func %sNames() []string {\n\treturn _%sNames\n}\n\n",
				enumInfo.EnumName, enumInfo.EnumName))

			file.WriteString(fmt.Sprintf("func %sFromString(value string) (%s, bool) {"+
				"\n\tenum, has := _%sMap[value]\n\treturn enum, has\n}\n\n",
				enumInfo.EnumName, enumInfo.EnumName, enumInfo.EnumName))

			file.WriteString(fmt.Sprintf("func (en %s) IsValid() bool {\n\treturn 0 < en && en <= %d\n}\n\n",
				enumInfo.EnumName, len(enumInfo.ValueNames)))

		case "string":
			file.WriteString(fmt.Sprintf("func (en %s) IsValid() bool {\n\treturn ", enumInfo.EnumName))

			for i, value := range enumInfo.ValueNames {
				fieldName := genEnumName(value, enumInfo.EnumName, enumInfo.reversedName)
				if i == 0 {
					file.WriteString(fmt.Sprintf("en == %s", fieldName))
				} else {
					file.WriteString(fmt.Sprintf(" ||\n\t\ten == %s", fieldName))
				}
			}

			file.WriteString("\n}\n\n")
		}

		file.WriteString(fmt.Sprintf("func %sValues() []%s {\n\treturn []%s{\n",
			enumInfo.EnumName, enumInfo.EnumName, enumInfo.EnumName))

		for _, value := range enumInfo.ValueNames {
			fieldName := genEnumName(value, enumInfo.EnumName, enumInfo.reversedName)
			file.WriteString(fmt.Sprintf("\t\t%s,\n", fieldName))
		}

		file.WriteString("\t}\n}\n\n")

		file.WriteString(fmt.Sprintf("func (en %s) String() string { \n", enumInfo.EnumName))
		switch enumInfo.TypeName {
		case "int":
			file.WriteString(fmt.Sprintf("\treturn _%sNames[en]\n}\n\n", enumInfo.EnumName))
		case "string":
			file.WriteString("\treturn string(en)\n}\n\n")
		}
	}

	return nil
}

func genEnumName(name, enumName string, reversed bool) string {
	if reversed {
		return toPascalCase(name) + enumName
	}
	return enumName + toPascalCase(name)
}
